# 东北大学操作系统课设-文件系统
## 工具链
* `Linux Ubuntu`环境
* `vscode`开发
* `CMake`构建
* `C++ 17`代码
* `GCC 11.4`编译
* `Git`版本管理
* `clang`前端提示
* `clang-format`统一代码风格

## 支持功能：
1. `Load` 导入本地文件
2. 硬链接
3. 拷贝
4. 重命名
5. 移动
6. 树状用户管理
7. 随写随刷保证一致性
8. 共享内存实现多进程共享
9. 用信号量上超大粒度锁避免竞争

## 框架设计：
* `disk.cpp` 封装磁盘操作
* `file.cpp` 调用 `disk.cpp` 函数实现并封装文件操作
* `user.cpp` 和 `director.cpp` 调用 `disk.cpp` 和 `file.cpp` 实现高级操作
* 拓展功能只要在对应模块修改即可，代码复用高。高级操作基本不需要调用 `disk.cpp` 的函数
* 目标是管理`50MB`的磁盘，当然也可以进行拓展。只需要在`disk`和`file`之间加一个缓冲池`buffer`再一层封装磁盘操作即可。
* 这里为了简单，让内存和磁盘一对一，可以直接拷贝
* 磁盘组织：`[superblock(512bytes)][inode(MAX_BLOCK_NUMBER * 128bytes)][block(MAX_BLOCK_NUMBER * 4096bytes)]`。具体配置信息可见`head.h`
* `superblock` 存储一些必要信息，根目录`/`和存储用户信息用的`inode`以及超级栈
* `inode` 节点`128`字节 `block` 块`4096`字节
* `inode`和`block`不存储空闲与否的状态信息，用分组链表管理节点分配
* 用户管理采用树状的结构，上级可以修改下级，下级不可以修改上级
* 用`file.cpp`中的`getBlock`函数屏蔽多级索引，其他地方无需关心多级索引

## 缺点：
* 头文件里面定义了过多函数还有全局变量
* 没有让磁盘、文件和高级操作这三个模块解耦，存在一些依赖，导致高级操作很多包含在了`directory.cpp`中
* 最开始写的时候没考虑链接，把文件名存在了`inode`节点中，导致后面写链接的时候很麻烦
* 分配`inode`节点编号和磁盘的`block`的编号是一个编号。会导致一些`inode`节点和`block`块被浪费掉，正确做法应该是为`inode`节点和`block`节点分别维护一个成组链接结构，避免浪费; 或者让`inode`和`block`共用一个块。测试之后，发现最好情况是`50MB`可以用到`48MB`存储内容。
* 文件夹在写的时候，忘记考虑本级`.`和上级`..`了，导致一些操作在使用的时候很别扭，不过倒是挺容易修改的，因为`inode`节点里面存着上一级目录的编号
* 因为没有解析路径的部分，所以仅支持相对路径，并且仅支持`..`，不支持绝对路径和多级路径
* 随写随刷，效率不佳
* 多进程锁粒度非常大
* 写操作忘记考虑了文件夹的情况，导致在`main.cpp`中使用了`disk.cpp`的函数
* 代码基本没有考虑效率，只为了更快完成

# 吐槽
听某个老师说，二十多年前东北大学的操作系统课设就是这个~🤣

这课设，本来寻思给网上抄个的，找着个，然后寻思看看就完事了🤔

结果发现，代码复用率极低，特别多重复无用的代码，函数基本没考虑复用，一千行左右就能完成的任务，却用两千多行😇

指针要么不用，要么乱飞，看懂代码比自己写代码还难😭

所以我重新写了一个，经过比较多测试，bug相对较少，供后人参考🤓

本来寻思用 `Rust` 或者 `Go` 来写的，但是 `Go` 的指针用的太麻烦，而 `Rust` 用的不太熟练🤦‍♀️

最后还是觉得`C/C++`更方便写🤡

前面工具链看着挺多，其实都怪`C/C++`没有官方配套的工具链，要是`Rust`或者`Go`，只需要一个`vscode`，剩下的连`Linux Ubuntu`都不需要，自带跨平台能力🤩

当然指针强转型和调用`Linux`系统调用的时候`unsafe`乱飞就一用一个不吱声了😀

`C/C++`我真是又爱用又爱喷😡