# 东北大学操作系统课设-文件系统
`Linux`环境，用到了`mmap, pwrite, pread, sem`等函数
`cmake`构建项目
`C++`完成代码

支持 `Load` 导入本地文件、硬链接、拷贝、重命名、移动、树状用户管理、随写随刷保证一致性。

## 框架设计：
* `disk.cpp` 封装磁盘操作
* `file.cpp` 调用 `disk.cpp` 函数实现并封装文件操作
* `user.cpp` 和 `director.cpp` 调用 `disk.cpp` 和 `file.cpp` 实现高级操作
* 拓展功能只要在对应模块修改即可，代码复用高。高级操作基本不需要调用 `disk.cpp` 的函数
目标是管理`50MB`的磁盘，当然也可以进行拓展。
只需要在`disk`和`file`之间加一个缓冲池`buffer`再一层封装磁盘操作即可。
这里为了简单，让内存和磁盘一对一，可以直接拷贝
磁盘组织：`[superblock][inode][block]`

`superblock` 存储一些必要信息，根目录`/`和存储用户信息用的`inode`以及超级栈
`inode` 节点`128`字节
`block` 块`512`字节
为了对齐，让四个`inode`节点放在一个`block`中
`inode`和`block`不存储空闲与否的状态信息，用分组链表管理节点分配。
用户管理采用树状的结构，上级可以修改下级，下级不可以修改上级。

## 缺点：
* 头文件里面定义了过多函数还有全局变量
* 没有让磁盘、文件和高级操作这三个模块解耦，存在一些依赖
* 最开始写的时候没考虑链接，把文件名存在了`inode`节点中，导致后面写链接的时候很麻烦
* 分配`inode`节点编号和磁盘的`block`的编号是一个编号。会导致一些`inode`节点和磁盘空间被浪费掉，正确做法应该是为`inode`节点和`block`节点分别维护一个成组链接结构，避免浪费。测试之后，发现最好情况是`50MB`可以用到`40MB`存储内容。
* 文件夹在写的时候，忘记考虑本级`.`和上级`..`了，导致一些操作在使用的时候很别扭，不过倒是挺容易修改的，因为`inode`节点里面存着上一级目录的编号

# 吐槽
听四十多岁的老师说，他在东北大学上学的时候，操作系统课设就是这个~
这课设，本来寻思给网上抄个的，找着个，然后寻思看看就完事了
结果越看越火大，代码写的依托构式，两千多行的代码，结果复用率极低，特别多重复无用的代码，写这种和内存和磁盘交互的代码居然连指针都不用。
结果我重新写了一个，基本没啥bug，供后人参考
本来寻思用 `Rust` 或者 `Go` 来写的，但是 `Go` 的指针用的太麻烦，而 `Rust` 用的不太熟练
最后还是觉得`C/C++`更方便写